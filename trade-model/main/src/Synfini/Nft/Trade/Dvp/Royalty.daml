module Synfini.Nft.Trade.Dvp.Royalty where

import DA.Assert
import DA.Finance.Asset
import DA.Finance.Trade.Dvp
import DA.Finance.Trade.Dvp.Settlement
import DA.Finance.Trade.SettlementInstruction
import DA.Finance.Types
import DA.Functor (void)
import DA.List
import DA.Set (Set)
import qualified DA.Set as Set
import Synfini.Nft
import Synfini.Nft.Trade.Dvp
import Synfini.Nft.Trade.Dvp.Settlement
import Synfini.Nft.Trade.SettlementInstruction

template NftPurchaseWithRoyalty
  with
    purchaseMasterAgreement : MasterAgreement
    purchaseTradeId : Id
    royaltyMasterAgreement : MasterAgreement
    royaltyTradeId : Id
      -- ^ The identifier of the trade within the master agreement.
      -- The tradeId.signatories can be left empty.
    buyer : Party
    collectionId : CollectionId
    tokenId : TokenId
    payments : [Asset]
    status : SettlementStatus
    settlementDate : Optional Date
    observers : Set Party
  where
    signatory purchaseMasterAgreement.id.signatories, royaltyMasterAgreement.id.signatories
    observer observers,
      purchaseMasterAgreement.party1,
      purchaseMasterAgreement.party2,
      royaltyMasterAgreement.party1,
      royaltyMasterAgreement.party2

    key (purchaseMasterAgreement.id, purchaseTradeId) : (Id, Id)
    maintainer key._1.signatories

    --ensure masterAgreement.id.signatories `Set.isSubsetOf` mconcat []

-- Nft dvp: buyer <--> seller. Can ctrl this via buyer or seller. We have auth of buyer, seller wallet sigs
-- Dvp: buyer <--> issuer. Can ctrl this via buyer.
-- Ctrl must include buyer

data RoyaltyRule_Purchase_Result = RoyaltyRule_Purchase_Result
  with
    purchaseCid : ContractId NftPurchaseWithRoyalty
    royaltyRuleCid : ContractId RoyaltyRule
    deliveryNftCid : ContractId Nft
    paymentDepositCids : [[ContractId AssetDeposit]]
    royalityPaymentDepositCids : [[ContractId AssetDeposit]]
  deriving (Show, Eq)

template RoyaltyRule
  with
    collectionId : CollectionId
    tokenId : TokenId
    issuer : Party
    wallet : Wallet
    royalty : Decimal
    observers : Set Party
  where
    signatory collectionId.signatories, tokenId.signatories, wallet.id.signatories
    observer observers

    ensure royalty > 0.0

    key (collectionId, tokenId) : (CollectionId, TokenId)
    maintainer key._1.signatories

    choice RoyaltyRule_Purchase : RoyaltyRule_Purchase_Result
      with
        purchaseMasterAgreement : MasterAgreement
        royaltyMasterAgreement : MasterAgreement
        purchaserWallet : Wallet
        purchaseCid : ContractId NftPurchaseWithRoyalty
        paymentInstructionCids : [ContractId SettlementInstruction]
        deliveryInstructionCid : ContractId NftSettlementInstruction
        royaltyPaymentInstructionCids : [ContractId SettlementInstruction]
      controller
        purchaserWallet.owner, purchaserWallet.id.signatories, purchaseMasterAgreement.id.signatories, royaltyMasterAgreement.id.signatories
      do
        -- Unlock the Nft to allow transfer
        deliveryInstruction <- fetch deliveryInstructionCid
        case deliveryInstruction.method of
          FreeTransfer ->
            void $ create FreeTransferRule with
              collectionId
              tokenId
              wallet
              observers = Set.empty
          WalletControlled ->
            void $ create WalletControlledTransferRule with
              collectionId
              tokenId
              wallet
              observers = Set.empty

        -- Settle purchase Dvp
        purchase <- fetch purchaseCid
        purchase.purchaseMasterAgreement === purchaseMasterAgreement
        purchase.royaltyMasterAgreement === royaltyMasterAgreement
        purchase.buyer === purchaserWallet.owner
        assertMsg
          "Wallet owner must be a counter party in purchase master agreement"
          (wallet.owner == purchase.purchaseMasterAgreement.party1 || wallet.owner == purchase.purchaseMasterAgreement.party2)
        let purchaseDvp = Dvp with
              masterAgreement = purchase.purchaseMasterAgreement
              tradeId = purchase.purchaseTradeId
              buyer = purchase.buyer
              status = purchase.status
              settlementDate = purchase.settlementDate
              payments = purchase.payments
              deliveries = []
              observers = purchase.observers
        let purchaseNftDvp = NftDvp with
              dvp = purchaseDvp
              paymentNfts = []
              deliveryNfts = [(purchase.collectionId, purchase.tokenId)]
        purchaseNftDvpCid <- create purchaseNftDvp
        purchaseSettlementResult <- exerciseByKey
          @NftDvpSettlementRule
          purchase.purchaseMasterAgreement.id
          NftDvpSettlementRule_Process with
            nftDvpCid = purchaseNftDvpCid
            paymentInstructionCids
            deliveryInstructionCids = []
            nftPaymentInstructionCids = []
            nftDeliveryInstructionCids = [deliveryInstructionCid]
            ctrl = purchaserWallet.owner
        archive purchaseNftDvpCid

        -- Lock Nft
        case purchaseSettlementResult.deliveryNftCids of
          [FreeTransferProcessResult _ transferRuleCid] -> archive transferRuleCid
          [WalletControlledProcessResult _ transferRuleCid] -> archive transferRuleCid
          _ -> error "Internal error"

        -- Settle royalty Dvp
        let royalties = (\asset -> asset with quantity = asset.quantity * royalty) <$> purchase.payments
        let royaltyDvp = Dvp with
              masterAgreement = purchase.royaltyMasterAgreement
              tradeId = purchase.royaltyTradeId
              buyer = purchaserWallet.owner
              status = purchase.status
              settlementDate = purchase.settlementDate
              payments = royalties
              deliveries = []
              observers = purchase.observers
        assertMsg
          "Issuer must be a counter party in royalty master agreement"
          (issuer == purchase.royaltyMasterAgreement.party1 || issuer == purchase.royaltyMasterAgreement.party2)
        royaltyDvpCid <- create  royaltyDvp
        royaltySettlementResult <- exerciseByKey
          @DvpSettlementRule
          purchase.royaltyMasterAgreement.id
          DvpSettlement_Process with
            dvpCid = royaltyDvpCid
            paymentInstructionCids = royaltyPaymentInstructionCids
            deliveryInstructionCids = []
            ctrl = purchaserWallet.owner
        archive royaltyDvpCid

        -- Create new purchase contract
        archive purchaseCid
        settledPurchaseCid <- create purchase with
          status = SettlementStatus_Settled

        -- Create new royalty rule
        royaltyRuleCid <- create this with
          wallet = purchaserWallet

        pure RoyaltyRule_Purchase_Result with
          purchaseCid = settledPurchaseCid
          royaltyRuleCid
          deliveryNftCid = (head purchaseSettlementResult.deliveryNftCids).nftCid
          paymentDepositCids = purchaseSettlementResult.paymentDepositCids
          royalityPaymentDepositCids = royaltySettlementResult.paymentDepositCids
