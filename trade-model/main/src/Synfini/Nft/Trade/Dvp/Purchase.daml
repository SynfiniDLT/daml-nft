module Synfini.Nft.Trade.Dvp.Purchase where

import DA.Assert
import DA.Finance.Asset
import DA.Finance.Trade.Dvp
import DA.Finance.Trade.Dvp.Settlement
import DA.Finance.Trade.SettlementInstruction
import DA.Finance.Types
import DA.List
import qualified DA.Optional as O
import DA.Set (Set)
import qualified DA.Set as Set
import qualified DA.Traversable as T
import Synfini.Nft
import Synfini.Nft.Trade.Dvp
import Synfini.Nft.Trade.Dvp.Settlement
import Synfini.Nft.Trade.SettlementInstruction

template NftPurchase
  with
    masterAgreement : MasterAgreement
    tradeId : Id
    royaltyMasterAgreement : Optional MasterAgreement
    royaltyTradeId : Optional Id
      -- ^ The identifier of the trade within the master agreement.
      -- The tradeId.signatories can be left empty.
    buyer : Party
    collectionId : CollectionId
    tokenId : TokenId
    payments : [Asset]
    status : SettlementStatus
    settlementDate : Optional Date
    observers : Set Party
  where
    signatory masterAgreement.id.signatories, O.optional Set.empty (.id.signatories) royaltyMasterAgreement
    observer observers,
      masterAgreement.party1,
      masterAgreement.party2,
      (.party1) <$> royaltyMasterAgreement,
      (.party2) <$> royaltyMasterAgreement

    key (masterAgreement.id, tradeId) : (Id, Id)
    maintainer key._1.signatories

template NftPurchaseSettlementRule
  with
    masterAgreement : MasterAgreement
    royaltyMasterAgreement : Optional MasterAgreement
  where
    signatory masterAgreement.id.signatories, O.optional Set.empty (.id.signatories) royaltyMasterAgreement

    key (masterAgreement.id, (.id) <$> royaltyMasterAgreement) : (Id, Optional Id)
    maintainer key._1.signatories

    nonconsuming choice NftPurchaseSettlementRule_Purchase : NftPurchaseRule_Purchase_Result
      with
        collectionId : CollectionId
        tokenId : TokenId
        purchaserWallet : Wallet
        purchaseCid : ContractId NftPurchase
        paymentInstructionCids : [ContractId SettlementInstruction]
        deliveryInstructionCid : ContractId NftSettlementInstruction
        royaltyPaymentInstructionCids : Optional [ContractId SettlementInstruction]
      controller purchaserWallet.owner, purchaserWallet.id.signatories
      do
        exerciseByKey @NftPurchaseRule (collectionId, tokenId) NftPurchaseRule_Purchase with ..

data NftPurchaseRule_Purchase_Result = NftPurchaseRule_Purchase_Result
  with
    purchaseCid : ContractId NftPurchase
    purchaseRuleCid : ContractId NftPurchaseRule
    deliveryNftCid : ContractId Nft
    paymentDepositCids : [[ContractId AssetDeposit]]
    royalityPaymentDepositCids : Optional [[ContractId AssetDeposit]]
  deriving (Show, Eq)

template NftPurchaseRule
  with
    collectionId : CollectionId
    tokenId : TokenId
    issuer : Party
    wallet : Wallet
    royalty : Optional Decimal
    observers : Set Party
  where
    signatory collectionId.signatories, tokenId.signatories, wallet.id.signatories
    observer observers

    ensure O.optional True (> 0.0) royalty

    key (collectionId, tokenId) : (CollectionId, TokenId)
    maintainer key._1.signatories

    choice NftPurchaseRule_Purchase : NftPurchaseRule_Purchase_Result
      with
        masterAgreement : MasterAgreement
        royaltyMasterAgreement : Optional MasterAgreement
        purchaserWallet : Wallet
        purchaseCid : ContractId NftPurchase
        paymentInstructionCids : [ContractId SettlementInstruction]
        deliveryInstructionCid : ContractId NftSettlementInstruction
        royaltyPaymentInstructionCids : Optional [ContractId SettlementInstruction]
      controller
        purchaseControllers masterAgreement royaltyMasterAgreement purchaserWallet
      do
        -- Unlock the Nft to allow transfer
        deliveryInstruction <- fetch deliveryInstructionCid
        create NftTransferRule with
          collectionId
          tokenId
          wallet
          observers = Set.empty

        -- Settle purchase Dvp
        purchase <- fetch purchaseCid
        purchase.masterAgreement === masterAgreement
        purchase.royaltyMasterAgreement === royaltyMasterAgreement
        purchase.buyer === purchaserWallet.owner
        assertMsg
          "Wallet owner must be a counter party in purchase master agreement"
          (wallet.owner == purchase.masterAgreement.party1 || wallet.owner == purchase.masterAgreement.party2)
        let purchaseDvp = Dvp with
              masterAgreement = purchase.masterAgreement
              tradeId = purchase.tradeId
              buyer = purchase.buyer
              status = purchase.status
              settlementDate = purchase.settlementDate
              payments = purchase.payments
              deliveries = []
              observers = purchase.observers
        let purchaseNftDvp = NftDvp with
              dvp = purchaseDvp
              paymentNfts = []
              deliveryNfts = [(purchase.collectionId, purchase.tokenId)]
        purchaseNftDvpCid <- create purchaseNftDvp
        purchaseSettlementResult <- exerciseByKey
          @NftDvpSettlementRule
          purchase.masterAgreement.id
          NftDvpSettlementRule_Process with
            nftDvpCid = purchaseNftDvpCid
            paymentInstructionCids
            deliveryInstructionCids = []
            nftPaymentInstructionCids = []
            nftDeliveryInstructionCids = [deliveryInstructionCid]
            ctrl = purchaserWallet.owner
        archive purchaseNftDvpCid

        -- Lock Nft
        case purchaseSettlementResult.deliveryNftCids of
          [(_, transferRuleCid)] -> archive transferRuleCid
          _ -> error "Internal error: unexpected list length"

        -- Settle royalty Dvp
        optRoyaltySettlementResult <- T.forA royalty $ \smRoyalty -> do
          let smRoyaltyMasterAgreement = O.fromSome royaltyMasterAgreement
          let royalties = (\asset -> asset with quantity = asset.quantity * smRoyalty) <$> purchase.payments
          let royaltyDvp = Dvp with
                masterAgreement = smRoyaltyMasterAgreement
                tradeId = O.fromSome purchase.royaltyTradeId
                buyer = purchaserWallet.owner
                status = purchase.status
                settlementDate = purchase.settlementDate
                payments = royalties
                deliveries = []
                observers = purchase.observers
          assertMsg
            "Issuer must be a counter party in royalty master agreement"
            (issuer == smRoyaltyMasterAgreement.party1 || issuer == smRoyaltyMasterAgreement.party2)
          royaltyDvpCid <- create royaltyDvp
          royaltySettlementResult <- exerciseByKey
            @DvpSettlementRule
            smRoyaltyMasterAgreement.id
            DvpSettlement_Process with
              dvpCid = royaltyDvpCid
              paymentInstructionCids = O.fromSome royaltyPaymentInstructionCids
              deliveryInstructionCids = []
              ctrl = purchaserWallet.owner
          archive royaltyDvpCid
          pure royaltySettlementResult

        -- Create new purchase contract
        archive purchaseCid
        settledPurchaseCid <- create purchase with
          status = SettlementStatus_Settled

        -- Create new purchase rule
        purchaseRuleCid <- create this with
          wallet = purchaserWallet

        pure NftPurchaseRule_Purchase_Result with
          purchaseCid = settledPurchaseCid
          purchaseRuleCid
          deliveryNftCid = (head purchaseSettlementResult.deliveryNftCids)._1
          paymentDepositCids = purchaseSettlementResult.paymentDepositCids
          royalityPaymentDepositCids = (.paymentDepositCids) <$> optRoyaltySettlementResult

purchaseControllers : MasterAgreement -> Optional MasterAgreement -> Wallet -> Set Party
purchaseControllers masterAgreement royaltyMasterAgreement purchaserWallet = mconcat [
    Set.singleton purchaserWallet.owner,
    purchaserWallet.id.signatories,
    masterAgreement.id.signatories,
    O.optional Set.empty (.id.signatories) royaltyMasterAgreement
  ]
